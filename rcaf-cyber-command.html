<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>RCAF CYBER COMMAND: SUBNETTING MASTERCLASS</title>
    <style>
      /*
      ===================================================================================
      THEME & CORE STYLES: RCAF CYBER COMMAND
      - Military Cyber Interface: Deep navy, grid lines, and glowing accents.
      - Strict Color Palette: Neon Green (Network), Cyan (Host), Gold (Theory/Emphasis).
      - Font: Modern sans-serif for UI, monospace for technical data.
      ===================================================================================
      */
      :root {
        --bg-navy: #0A0F1E;
        --panel-bg: rgba(15, 22, 42, 0.7);
        --glass-border: rgba(0, 180, 255, 0.2);
        --text-primary: #E6F1FF;
        --text-secondary: #A0B3D4;
        --net-color: #00ff88;
        --host-color: #00ccff;
        --gold-color: #FFD700;
        --red-color: #ff4747;
        --radius: 12px;
        --font-body: 'Segoe UI', system-ui, -apple-system, sans-serif;
        --font-mono: 'Roboto Mono', ui-monospace, monospace;
      }

      * { box-sizing: border-box; margin: 0; padding: 0; }

      html { scroll-behavior: smooth; }

      body {
        background-color: var(--bg-navy);
        color: var(--text-primary);
        font-family: var(--font-body);
        line-height: 1.7;
        /* Grid background effect */
        background-image: 
          linear-gradient(rgba(0, 180, 255, 0.05) 1px, transparent 1px),
          linear-gradient(90deg, rgba(0, 180, 255, 0.05) 1px, transparent 1px);
        background-size: 30px 30px;
      }

      .course-container {
        max-width: 1000px;
        margin: 2rem auto;
        padding: 1rem;
        display: flex;
        flex-direction: column;
        gap: 1.5rem;
      }
      
      .main-header {
        text-align: center;
        margin-bottom: 1rem;
        border-bottom: 1px solid var(--glass-border);
        padding-bottom: 1rem;
      }
      .main-header h1 {
        font-size: 2.5rem;
        font-weight: 800;
        color: var(--host-color);
        letter-spacing: 1px;
        text-shadow: 0 0 15px rgba(0, 204, 255, 0.2);
      }
      
      /* 
       * ===================================================================================
       * COLLAPSIBLE CHAPTERS
       * ===================================================================================
      */
      .chapter {
        background: var(--panel-bg);
        border: 1px solid var(--glass-border);
        border-radius: var(--radius);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        transition: background-color 0.3s ease;
      }
      .chapter[open] { background: rgba(20, 28, 50, 0.8); }
      .chapter summary {
        display: flex;
        align-items: center;
        padding: 1.5rem;
        cursor: pointer;
        outline: none;
        font-size: 1.5rem;
        font-weight: 700;
      }
      .chapter summary::-webkit-details-marker { display: none; }
      .chapter summary::before {
        content: 'â–º';
        font-size: 1rem;
        margin-right: 1rem;
        color: var(--host-color);
        transition: transform 0.3s ease;
      }
      .chapter[open] > summary::before { transform: rotate(90deg); }
      .chapter-content { padding: 0 1.5rem 1.5rem 1.5rem; }
      
      /* New Scroll Animation Classes */
      .scroll-animate {
        opacity: 0;
        transform: translateY(30px);
        transition: opacity 0.6s ease-out, transform 0.6s ease-out;
      }
      .scroll-animate.is-visible {
        opacity: 1;
        transform: translateY(0);
      }

      .chapter-content p, .chapter-content ul {
        color: var(--text-secondary);
        margin-bottom: 1rem;
        max-width: 75ch;
      }
      .chapter-content ul { list-style-position: inside; padding-left: 1rem; }
      .chapter-content strong { color: var(--gold-color); }

      .interactive-area {
        margin-top: 1.5rem;
        padding: 1.5rem;
        background: rgba(0,0,0,0.2);
        border-radius: 8px;
        border: 1px solid var(--glass-border);
      }
      
      h3 {
          font-size: 1.2rem;
          color: var(--gold-color);
          margin-bottom: 0.5rem;
          border-bottom: 1px solid var(--glass-border);
          padding-bottom: 0.5rem;
      }
      
      .btn {
        background: linear-gradient(90deg, var(--net-color), var(--host-color));
        color: #001;
        padding: 12px 24px;
        border-radius: 8px;
        border: none;
        cursor: pointer;
        font-weight: 700;
        font-size: 1rem;
        transition: opacity 0.2s ease;
      }
      .btn:hover { opacity: 0.9; }

      /* Chapter 1: Binary Switchboard */
      .byte-switchboard { display: grid; grid-template-columns: repeat(8, 1fr); gap: 10px; }
      .bit-toggle {
        aspect-ratio: 1 / 1; border-radius: 8px; display: flex; flex-direction: column; align-items: center; justify-content: center;
        background: rgba(0,0,0,0.2); border: 1px solid var(--glass-border);
        cursor: pointer; font-family: var(--font-mono); transition: all .2s ease; user-select: none;
      }
      .bit-toggle.on { background: rgba(0, 255, 136, 0.15); border-color: var(--net-color); }
      .bit-toggle .power { font-size: 1.1rem; font-weight: 700; }
      .bit-toggle .value { font-size: 0.9rem; color: var(--text-secondary); margin-top: 4px; }
      .byte-total { text-align: center; margin-top: 1rem; font-size: 2rem; font-weight: 700; color: var(--gold-color); }

      /* Chapter 2: CIDR Slider */
      .slider-container { display: flex; flex-direction: column; gap: 1rem; }
      #cidrSlider { width: 100%; }
      .bar-chart { display: flex; height: 40px; background: rgba(0,0,0,0.2); border-radius: 4px; overflow: hidden; }
      #networksBar { background: var(--net-color); transition: width 0.3s ease; }
      #hostsBar { background: var(--host-color); transition: width 0.3s ease; }
      .bar-labels { display: flex; justify-content: space-between; font-size: 0.9rem; margin-top: 0.5rem; }

      /* Chapter 4: Calculator */
      .calculator-input { display: flex; gap: 1rem; margin-bottom: 1rem; }
      .calculator-input input {
        flex: 1; background: rgba(0,0,0,0.2); border: 1px solid var(--glass-border);
        padding: 10px 14px; border-radius: 8px; color: var(--text-primary);
        font-family: var(--font-mono); font-size: 1.1rem;
      }
      .calc-log { font-family: var(--font-mono); font-size: 1rem; min-height: 150px; background: rgba(0,0,0,0.3); padding: 1rem; border-radius: 8px; }
      .log-line { opacity: 0; transition: opacity 0.5s ease; }
      .log-line.visible { opacity: 1; }
      .calc-results { margin-top: 1rem; display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 10px; }
      .result-card { background: rgba(0,0,0,0.2); padding: 10px; border-radius: 8px; }
      .result-card .label { font-size: 0.8rem; color: var(--text-secondary); }
      .result-card .value { font-size: 1.1rem; font-family: var(--font-mono); font-weight: 700; }
      .value.net { color: var(--net-color); }
      .value.host { color: var(--host-color); }
      
      /* Chapter 5: VLSM Diagram */
      .vlsm-diagram { position: relative; border: 2px solid var(--gold-color); padding: 1rem; border-radius: 8px; background: rgba(255, 215, 0, 0.05); text-align: center; margin-top: 1rem; }
      .vlsm-diagram .vlsm-box { border: 1px solid var(--text-secondary); padding: 1rem; margin: 0.5rem; }
      .vlsm-diagram .split-line { position: absolute; left: 50%; top: 3.5rem; bottom: 0.5rem; border-left: 2px dashed var(--net-color); }
      .vlsm-sub-container { display: flex; justify-content: space-around; }

      /* Chapter 6: Quiz */
      .quiz-controls { display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; }
      #quizDifficulty { background: rgba(0,0,0,0.2); border: 1px solid var(--glass-border); padding: 8px; border-radius: 8px; color: var(--text-primary); font-family: var(--font-body); }
      .quiz-question { margin: 1rem 0; font-size: 1.2rem; text-align: center; }
      .quiz-options { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
      .option-btn { background: rgba(0,0,0,0.2); border: 1px solid var(--glass-border); color: var(--text-primary); padding: 1rem; border-radius: 8px; cursor: pointer; text-align: center; transition: background 0.2s; font-family: var(--font-mono); font-size: 1rem; }
      .option-btn:hover { background: rgba(255,255,255,0.1); }
      #quizFeedback { margin-top: 1rem; padding: 1rem; border-radius: 8px; display: none; }
      
      /* 
       * ===================================================================================
       * CHAPTER 7: AI CHAT MENTOR
       * ===================================================================================
      */
      #aiChatWindow {
        height: 300px;
        overflow-y: auto;
        background: rgba(0,0,0,0.3);
        border: 1px solid var(--glass-border);
        padding: 1rem;
        border-radius: 8px;
        margin-bottom: 1rem;
      }
      .chat-message {
        margin-bottom: 1rem;
        display: flex;
        flex-direction: column;
      }
      .chat-message .author {
        font-size: 0.8rem;
        font-weight: 700;
        margin-bottom: 0.25rem;
      }
      .chat-message .text {
        padding: 0.75rem 1rem;
        border-radius: 8px;
        max-width: 80%;
      }
      .chat-message.user { align-items: flex-end; }
      .chat-message.user .author { color: var(--host-color); }
      .chat-message.user .text { background-color: #1E293B; }
      .chat-message.ai .author { color: var(--net-color); }
      .chat-message.ai .text { background-color: #334155; }
      .chat-message.ai .text strong { color: var(--gold-color); }
      
      #aiChatInput {
        width: 100%;
        background: rgba(0,0,0,0.2);
        border: 1px solid var(--glass-border);
        padding: 12px;
        border-radius: 8px;
        color: var(--text-primary);
        font-family: var(--font-mono);
        font-size: 1rem;
      }


      /* Responsive */
      @media (max-width: 768px) {
        .main-header h1 { font-size: 1.8rem; }
        .chapter summary { font-size: 1.2rem; padding: 1rem; }
        .chapter-content { padding: 0 1rem 1rem 1rem; }
        .quiz-options { grid-template-columns: 1fr; }
      }
    </style>
</head>
<body>

    <main class="course-container">
        <header class="main-header">
            <h1>RCAF CYBER COMMAND</h1>
            <p>SUBNETTING MASTERCLASS</p>
        </header>

        <!-- CHAPTER 1 -->
        <details class="chapter scroll-animate" open id="chapter-1">
            <summary>Chapter 1: The Fundamentals</summary>
            <div class="chapter-content">
                <p>Welcome, Recruit. Before you can defend the network, you must understand its language. The language of the internet is based on IP addresses.</p>
                <ul>
                    <li>An <strong>IP Address</strong> (like 192.168.1.1) is a unique address for a device on a network.</li>
                    <li>It is made of four numbers called <strong>Octets</strong>. Each octet is a <strong>Byte</strong> (8 <strong>Bits</strong>).</li>
                    <li>A bit is the smallest unit of data: either a <strong>1 (on)</strong> or a <strong>0 (off)</strong>.</li>
                </ul>
                <div class="interactive-area">
                    <h3>Binary Switchboard</h3>
                    <p>Click the switches to see how 8 bits create a decimal number from 0 to 255.</p>
                    <div class="byte-switchboard" id="byteSwitchboard"></div>
                    <div class="byte-total" id="byteTotal">0</div>
                </div>
                <div style="margin-top: 1.5rem;">
                    <h3>IP Address Classes & Ranges</h3>
                    <ul>
                        <li><strong>Class A, B, C:</strong> Old system for sizing networks. Largely replaced by CIDR.</li>
                        <li><strong>Private (RFC1918):</strong> IPs for internal networks (home, office). Not routable on the public internet.
                            <ul>
                                <li>10.0.0.0/8 | 172.16.0.0/12 | 192.168.0.0/16</li>
                            </ul>
                        </li>
                    </ul>
                </div>
            </div>
        </details>
        
        <!-- CHAPTER 2: FINDING BOUNDARIES -->
        <details class="chapter scroll-animate" id="chapter-2">
            <summary>Chapter 2: Finding Network, Broadcast, & Usable IPs</summary>
            <div class="chapter-content">
                <p>This is the most critical skill. Given an IP like <code>172.16.20.119 /26</code>, you must be able to find the three key addresses: the Network ID, the Broadcast IP, and the range of Usable IPs.</p>
                <h3>Step 1: Find the Magic Number</h3>
                <p>The CIDR (<code>/26</code>) tells you the mask. Chapter 3 has a cheat sheet, but for /26 the mask is 255.255.255.192. The "interesting" octet is the one that is not 255, so: <strong>192</strong>.</p>
                <p>The Magic Number is <code>256 - 192 = <strong>64</strong></code>. This is your block size. It means networks come in blocks of 64 addresses.</p>
                <h3>Step 2: Find the Network ID (The Start of the Block)</h3>
                <p>Look at the octet in the IP that corresponds to the interesting octet: 172.16.20.<strong>119</strong>. Find the multiple of your Magic Number (64) that is less than or equal to 119. The multiples are 0, 64, 128... The highest one without going over is <strong>64</strong>.</p>
                <p>So, the Network ID is <code>172.16.20.<strong>64</strong></code>.</p>
                <h3>Step 3: Find the Broadcast IP (The End of the Block)</h3>
                <p>The next block starts at the next multiple of 64 (which is 128). So, the next network would be 172.16.20.128. The Broadcast IP is the address right before that.</p>
                <p>So, the Broadcast IP is <code>172.16.20.<strong>127</strong></code>.</p>
                <h3>Step 4: Find the Usable IPs</h3>
                <p>This is the easy part. The usable range is everything between the Network and Broadcast addresses.</p>
                <ul>
                    <li><strong>First Usable IP</strong>: Network ID + 1 = <code>172.16.20.<strong>65</strong></code></li>
                    <li><strong>Last Usable IP</strong>: Broadcast IP - 1 = <code>172.16.20.<strong>126</strong></code></li>
                </ul>
                <div class="interactive-area">
                    <h3>Boundary Practice</h3>
                    <p>Let's drill this. For the IP and CIDR below, what are the Network and Broadcast IPs?</p>
                    <div class="quiz-question" id="boundaryProblem"></div>
                    <div class="calculator-input" style="margin-top: 1rem;">
                        <input type="text" id="boundaryNetwork" placeholder="Network ID...">
                        <input type="text" id="boundaryBroadcast" placeholder="Broadcast IP...">
                    </div>
                    <button id="boundaryCheckBtn" class="btn">Check Boundaries</button>
                    <div id="boundaryFeedback" style="margin-top: 1rem; padding: 1rem; border-radius: 8px; display: none;"></div>
                </div>
            </div>
        </details>

        <!-- CHAPTER 3 -->
        <details class="chapter scroll-animate" id="chapter-3">
            <summary>Chapter 3: The Magic Number</summary>
            <div class="chapter-content">
                <p>The fastest way to calculate subnets is the <strong>"Magic Number"</strong> method (also called Block Size).</p>
                <ul>
                    <li>Find the octet in the subnet mask that is <strong>not</strong> 255.</li>
                    <li>Calculate: <code>256 - [That Number] = Magic Number</code>.</li>
                    <li>Example: /27 mask is 255.255.255.<strong>224</strong> &rarr; <code>256 - 224 = 32</code>. The Magic Number is 32.</li>
                    <li>This means networks start at 0, 32, 64, 96... in that octet.</li>
                </ul>
                <div class="interactive-area">
                    <h3>Magic Number Cheat Sheet (/24 - /30)</h3>
                    <table id="magicNumberTable" style="width:100%; font-family:var(--font-mono); text-align:center;"></table>
                </div>
            </div>
        </details>

        <!-- CHAPTER 4 -->
        <details class="chapter scroll-animate" id="chapter-4">
            <summary>Chapter 4: The Ultimate Calculator</summary>
            <div class="chapter-content">
                <p>Use the tactical calculator to analyze any IP address. The animated log will walk you through the logic step-by-step.</p>
                <div class="interactive-area">
                    <div class="calculator-input">
                        <input type="text" id="calcIpInput" value="192.168.10.50">
                        <input type="text" id="calcCidrInput" value="/27" style="width: 80px;">
                        <button id="calcBtn" class="btn">Calculate</button>
                    </div>
                    <h3>Calculation Log</h3>
                    <div class="calc-log" id="calcLog"></div>
                    <h3 style="margin-top:1.5rem;">Final Analysis</h3>
                    <div class="calc-results" id="calcResults"></div>
                </div>
            </div>
        </details>

        <!-- CHAPTER 4.5: IP WORKOUT -->
        <details class="chapter scroll-animate" id="chapter-4.5">
            <summary>Chapter 4.5: The Drill Sergeant's IP Workout</summary>
            <div class="chapter-content">
                <p>Reading the steps is one thing, doing them is another. This drill will build your mental muscle memory for subnetting.</p>
                <h3>The 3-Step IP Workout</h3>
                <ol>
                    <li><strong>Find the Magic Number:</strong> Look at the CIDR (e.g., /26). Find the subnet mask octet that isn't 255 (for /26, it's 192). Calculate <code>256 - 192 = <strong>64</strong></code>. That's your block size.</li>
                    <li><strong>Find the Network ID:</strong> Look at the same octet in the IP address (e.g., 192.168.10.<strong>77</strong>). Find the multiple of the Magic Number (64) that is less than or equal to that number. Multiples are 0, 64, 128, 192... The answer is 64. The Network ID is 192.168.10.<strong>64</strong>.</li>
                    <li><strong>Find the Broadcast IP:</strong> The *next* network starts at the next multiple (64 + 64 = 128). So, the next network is 192.168.10.128. The broadcast address is the IP right before that: 192.168.10.<strong>127</strong>.</li>
                </ol>
                <p>Once you have those, the usable IPs are easy: First Usable is Network ID + 1, Last Usable is Broadcast IP - 1.</p>
                <div class="interactive-area">
                    <h3>IP Drill</h3>
                    <p>Given the following IP and CIDR, calculate the Network ID and Broadcast IP.</p>
                    <div class="quiz-question" id="drillProblem"></div>
                    <div class="calculator-input" style="margin-top: 1rem;">
                        <input type="text" id="drillNetworkId" placeholder="Your Network ID...">
                        <input type="text" id="drillBroadcastIp" placeholder="Your Broadcast IP...">
                    </div>
                    <button id="drillCheckBtn" class="btn">Check My Work</button>
                    <div id="drillFeedback" style="margin-top: 1rem; padding: 1rem; border-radius: 8px; display: none;"></div>
                </div>
            </div>
        </details>

        <!-- CHAPTER 5 -->
        <details class="chapter scroll-animate" id="chapter-5">
    <summary>Chapter 5: Advanced Concepts (VLSM)</summary>
            <div class="chapter-content">
                <p><strong>Variable Length Subnet Masking (VLSM)</strong> is an efficiency technique. Instead of cutting all subnets into equal sizes, you cut them into different sizes based on need, preventing wasted IP addresses.</p>
                <div class="interactive-area">
                    <h3>VLSM Diagram: /24 sliced into two /25s</h3>
                    <div class="vlsm-diagram">
                        /24 Block (e.g., 192.168.0.0/24)
                        <div class="split-line"></div>
                        <div class="vlsm-sub-container">
                            <div class="vlsm-box" style="border-color:var(--net-color)">/25 Subnet 1<br>(128 IPs)</div>
                            <div class="vlsm-box" style="border-color:var(--host-color)">/25 Subnet 2<br>(128 IPs)</div>
                        </div>
                    </div>
                </div>
            </div>
        </details>

<!-- CHAPTER 7 -->
<details class="chapter scroll-animate" id="chapter-6">
    <summary>Chapter 6: The Gauntlet</summary>
            <div class="chapter-content">
                <p>Test your skills. Select a difficulty and prove your mastery. Wrong answers will provide a hint explaining the logic.</p>
                <div class="interactive-area">
                    <div class="quiz-controls">
                        <select id="quizDifficulty">
                            <option value="1">Level 1: Recruit</option>
                            <option value="2">Level 2: Soldier</option>
                            <option value="3">Level 3: Commander</option>
                        </select>
                        <div id="quizScore">Score: 0</div>
                    </div>
                    <div class="quiz-question" id="quizQuestion"></div>
                    <div class="quiz-options" id="quizOptions"></div>
                    <div id="quizFeedback"></div>
                </div>
            </div>
        </details>
        
        <!-- CHAPTER 7: Wildcard Drill -->
        <details class="chapter scroll-animate" id="chapter-7">
            <summary>Chapter 7: The Wildcard Drill</summary>
            <div class="chapter-content">
                <p>A <strong>Wildcard Mask</strong> is the inverse of a subnet mask, used in router and firewall Access Control Lists (ACLs). To calculate it, subtract each subnet mask octet from 255.</p>
                <p>Example: A mask of 255.255.255.240 becomes a wildcard of 0.0.0.15.</p>
                <div class="interactive-area">
                    <div class="quiz-question" id="wildcardQuizQuestion"></div>
                    <div class="quiz-options" id="wildcardQuizOptions"></div>
                    <div id="wildcardQuizFeedback"></div>
                </div>
            </div>
        </details>
        
        <!-- CHAPTER 8: Reverse CIDR Challenge -->
        <details class="chapter scroll-animate" id="chapter-8">
            <summary>Chapter 8: Reverse CIDR Challenge</summary>
            <div class="chapter-content">
                <p>This is the ultimate test of understanding. Given a Network ID and a Broadcast address, you must determine the correct CIDR that creates this range.</p>
                <div class="interactive-area">
                    <div class="quiz-question" id="reverseCidrQuizQuestion"></div>
                    <div class="quiz-options" id="reverseCidrQuizOptions"></div>
                    <div id="reverseCidrQuizFeedback"></div>
                </div>
            </div>
        </details>
        
        <!-- CHAPTER 9: AI MENTOR -->
        <details class="chapter scroll-animate" id="chapter-9">
            <summary>Chapter 9: AI Cyber Mentor</summary>
            <div class="chapter-content">
                <p>Ask me questions about subnetting. I can provide definitions, explain concepts, or generate a new quiz question for you.</p>
                <div class="interactive-area">
                    <div id="aiChatWindow"></div>
                    <input type="text" id="aiChatInput" placeholder="Ask a question, e.g., 'what is a broadcast address?'" />
                </div>
            </div>
        </details>

    </main>

<script>
/**
 * RCAF CYBER COMMAND: SUBNETTING MASTERCLASS
 * Author: Gemini Advanced Agent
 * All logic is self-contained in this vanilla JavaScript block.
 */
document.addEventListener('DOMContentLoaded', () => {

    class MasterclassApp {
        constructor() {
            this.initChapter1();
            this.initChapter2();
            this.initChapter3();
            this.initChapter4();
            this.initChapter4_5();
            this.initChapter5();
            this.initChapter6();
            this.initChapter7();
            this.initChapter8();
            this.initChapter9();
            this.initScrollAnimations();
        }
        
        // NEW: SCROLL ANIMATION INITIALIZER
        initScrollAnimations() {
            const observer = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        entry.target.classList.add('is-visible');
                        observer.unobserve(entry.target);
                    }
                });
            }, { threshold: 0.1 });

            document.querySelectorAll('.scroll-animate').forEach(el => {
                observer.observe(el);
            });
        }

        // CHAPTER 1: FUNDAMENTALS
        initChapter1() {
            this.bits = [128, 64, 32, 16, 8, 4, 2, 1];
            this.bitState = [true, true, false, false, false, false, false, false]; // Default to 192
            this.switchboard = document.getElementById('byteSwitchboard');
            this.byteTotalEl = document.getElementById('byteTotal');
            if (!this.switchboard) return;
            this.renderBits();
        }

        renderBits() {
            this.switchboard.innerHTML = '';
            this.bits.forEach((val, i) => {
                const el = document.createElement('div');
                el.className = `bit-toggle ${this.bitState[i] ? 'on' : ''}`;
                el.setAttribute('role', 'switch');
                el.setAttribute('aria-checked', this.bitState[i]);
                el.innerHTML = `<div class="power">${val}</div><div class="value">${this.bitState[i] ? '1' : '0'}</div>`;
                el.addEventListener('click', () => {
                    this.bitState[i] = !this.bitState[i];
                    this.renderBits();
                });
                this.switchboard.appendChild(el);
            });
            this.updateByteTotal();
        }
        
        updateByteTotal() {
            const total = this.bits.reduce((sum, val, i) => sum + (this.bitState[i] ? val : 0), 0);
            this.byteTotalEl.textContent = total;
        }

        // CHAPTER 2: FINDING BOUNDARIES
        initChapter2() {
            this.boundaryProblemEl = document.getElementById('boundaryProblem');
            if (!this.boundaryProblemEl) return;
            this.boundaryNetworkInput = document.getElementById('boundaryNetwork');
            this.boundaryBroadcastInput = document.getElementById('boundaryBroadcast');
            this.boundaryCheckBtn = document.getElementById('boundaryCheckBtn');
            this.boundaryFeedbackEl = document.getElementById('boundaryFeedback');

            this.boundaryCheckBtn.addEventListener('click', () => this.checkBoundary());
            this.generateBoundaryProblem();
        }

        generateBoundaryProblem() {
            this.boundaryFeedbackEl.style.display = 'none';
            this.boundaryNetworkInput.value = '';
            this.boundaryBroadcastInput.value = '';

            const cidr = Math.floor(Math.random() * (28 - 25 + 1)) + 25; // /25 to /28
            const ip = [192, 168, 1, Math.floor(Math.random()*254)+1];
            
            const networkID = this.getNetworkID(ip, cidr);
            const broadcast = this.getBroadcastAddress(networkID, cidr);
            
            this.currentBoundaryProblem = {
                ip: ip.join('.'),
                cidr,
                correctNetworkId: networkID.join('.'),
                correctBroadcastIp: broadcast.join('.'),
            };
            
            this.boundaryProblemEl.innerHTML = `<strong>${this.currentBoundaryProblem.ip} /${this.currentBoundaryProblem.cidr}</strong>`;
        }

        checkBoundary() {
            const userNetworkId = this.boundaryNetworkInput.value.trim();
            const userBroadcastIp = this.boundaryBroadcastInput.value.trim();

            if (userNetworkId === this.currentBoundaryProblem.correctNetworkId && userBroadcastIp === this.currentBoundaryProblem.correctBroadcastIp) {
                this.boundaryFeedbackEl.style.background = 'rgba(0, 255, 136, 0.1)';
                this.boundaryFeedbackEl.style.borderColor = 'var(--net-color)';
                this.boundaryFeedbackEl.innerHTML = `<strong>Correct!</strong> Well done. New problem generated.`;
                setTimeout(() => this.generateBoundaryProblem(), 2000);
            } else {
                this.boundaryFeedbackEl.style.background = 'rgba(255, 71, 71, 0.1)';
                this.boundaryFeedbackEl.style.borderColor = 'var(--red-color)';
                
                let feedback = `<strong>Not quite.</strong> For <strong>${this.currentBoundaryProblem.ip} /${this.currentBoundaryProblem.cidr}</strong>:<br>`;
                feedback += `The correct Network ID was <strong>${this.currentBoundaryProblem.correctNetworkId}</strong>.<br>`;
                feedback += `The correct Broadcast IP was <strong>${this.currentBoundaryProblem.correctBroadcastIp}</strong>.<br>`;

                this.boundaryFeedbackEl.innerHTML = feedback;
            }
            this.boundaryFeedbackEl.style.display = 'block';
        }
        
        // CHAPTER 3: MAGIC NUMBER
        initChapter3() {
            const table = document.getElementById('magicNumberTable');
            if (!table) return;
            let html = `<thead><tr><th>CIDR</th><th>Mask Octet</th><th>Magic Number</th></tr></thead><tbody>`;
            for (let i = 24; i <= 30; i++) {
                const mask = this.cidrToMask(i);
                const magicOctet = mask[3];
                const magicNumber = 256 - magicOctet;
                html += `<tr><td>/${i}</td><td>.${magicOctet}</td><td>${magicNumber}</td></tr>`;
            }
            table.innerHTML = html + `</tbody>`;
        }

        // CHAPTER 4: CALCULATOR
        initChapter4() {
            this.calcIpInput = document.getElementById('calcIpInput');
            if (!this.calcIpInput) return;
            this.calcCidrInput = document.getElementById('calcCidrInput');
            this.calcBtn = document.getElementById('calcBtn');
            this.calcLog = document.getElementById('calcLog');
            this.calcResults = document.getElementById('calcResults');
            
            this.calcBtn.addEventListener('click', () => this.runCalculator());
        }

        async runCalculator() {
            this.calcLog.innerHTML = '';
            this.calcResults.innerHTML = '';
            
            const ipStr = this.calcIpInput.value.trim();
            const cidr = parseInt(this.calcCidrInput.value.replace('/', ''));
            const octets = this.ipToOctets(ipStr);

            if (!octets || isNaN(cidr) || cidr < 0 || cidr > 32) {
                this.logLine("Invalid input. Please check IP and CIDR.", true);
                return;
            }
            
            const mask = this.cidrToMask(cidr);
            const interestingOctetIndex = Math.floor((cidr - 1) / 8);
            const maskOctet = mask[interestingOctetIndex];
            const magicNumber = maskOctet === 255 ? 0 : 256 - maskOctet;


            await this.logLine(`Step 1: /${cidr} is in the <strong>${interestingOctetIndex + 1}th Octet</strong>.`);
            await this.sleep(1000);
            await this.logLine(`Step 2: Convert /${cidr} to Mask Octet &rarr; <strong>${maskOctet}</strong>.`);
            await this.sleep(1000);
            if (magicNumber > 0) {
              await this.logLine(`Step 3: Magic Number is 256 - ${maskOctet} = <strong>${magicNumber}</strong>.`);
              await this.sleep(1000);
            }

            const networkStartOctet = magicNumber > 0 ? Math.floor(octets[interestingOctetIndex] / magicNumber) * magicNumber : octets[interestingOctetIndex];
            
            if (magicNumber > 0) {
              let multiples = [];
              for (let i = 0; i < 256; i += magicNumber) multiples.push(i);
              await this.logLine(`Step 4: Multiples of ${magicNumber} are: ${multiples.slice(0, 5).join(', ')}...`);
              await this.sleep(1000);
              await this.logLine(`Step 5: Your IP's octet (${octets[interestingOctetIndex]}) is in the block starting at <strong>${networkStartOctet}</strong>.`);
            }
            
            const networkID = this.getNetworkID(octets, cidr);
            const broadcast = this.getBroadcastAddress(networkID, cidr);
            const firstUsable = this.nextIp(networkID);
            const lastUsable = this.prevIp(broadcast);
            const nextNetwork = this.nextIp(broadcast);
            
            this.renderCalcResults({ networkID, broadcast, firstUsable, lastUsable, nextNetwork, mask, magicNumber });
        }
        
        async logLine(message, isError = false) {
            const line = document.createElement('div');
            line.className = 'log-line';
            line.innerHTML = message;
            if(isError) line.style.color = 'var(--red-color)';
            this.calcLog.appendChild(line);
            await this.sleep(50);
            line.classList.add('visible');
        }

        renderCalcResults(data) {
            const results = [
                { label: 'Network ID', value: data.networkID.join('.'), class: 'net' },
                { label: 'Broadcast', value: data.broadcast.join('.'), class: 'host' },
                { label: 'First Usable IP', value: data.firstUsable.join('.'), class: 'host' },
                { label: 'Last Usable IP', value: data.lastUsable.join('.'), class: 'host' },
                { label: 'Next Network', value: data.nextNetwork.join('.'), class: 'net' },
                { label: 'Subnet Mask', value: data.mask.join('.'), class: '' },
            ];
            this.calcResults.innerHTML = results.map(r => `
                <div class="result-card">
                    <div class="label">${r.label}</div>
                    <div class="value ${r.class}">${r.value}</div>
                </div>
            `).join('');
        }

        // CHAPTER 4.5: IP WORKOUT
        initChapter4_5() {
            this.drillProblemEl = document.getElementById('drillProblem');
            if (!this.drillProblemEl) return;
            this.drillNetworkIdInput = document.getElementById('drillNetworkId');
            this.drillBroadcastIpInput = document.getElementById('drillBroadcastIp');
            this.drillCheckBtn = document.getElementById('drillCheckBtn');
            this.drillFeedbackEl = document.getElementById('drillFeedback');

            this.drillCheckBtn.addEventListener('click', () => this.checkDrill());
            this.generateDrillProblem();
        }

        generateDrillProblem() {
            this.drillFeedbackEl.style.display = 'none';
            this.drillNetworkIdInput.value = '';
            this.drillBroadcastIpInput.value = '';

            const cidr = Math.floor(Math.random() * (29 - 22 + 1)) + 22; // /22 to /29
            const ip = [172, 16, Math.floor(Math.random()*256), Math.floor(Math.random()*254)+1];
            
            const networkID = this.getNetworkID(ip, cidr);
            const broadcast = this.getBroadcastAddress(networkID, cidr);
            
            this.currentDrill = {
                ip: ip.join('.'),
                cidr,
                correctNetworkId: networkID.join('.'),
                correctBroadcastIp: broadcast.join('.'),
            };
            
            this.drillProblemEl.innerHTML = `<strong>${this.currentDrill.ip} /${this.currentDrill.cidr}</strong>`;
        }

        checkDrill() {
            const userNetworkId = this.drillNetworkIdInput.value.trim();
            const userBroadcastIp = this.drillBroadcastIpInput.value.trim();

            if (userNetworkId === this.currentDrill.correctNetworkId && userBroadcastIp === this.currentDrill.correctBroadcastIp) {
                this.drillFeedbackEl.style.background = 'rgba(0, 255, 136, 0.1)';
                this.drillFeedbackEl.style.borderColor = 'var(--net-color)';
                this.drillFeedbackEl.innerHTML = `<strong>Correct!</strong> Excellent work. Generating new problem...`;
                setTimeout(() => this.generateDrillProblem(), 2000);
            } else {
                this.drillFeedbackEl.style.background = 'rgba(255, 71, 71, 0.1)';
                this.drillFeedbackEl.style.borderColor = 'var(--red-color)';
                
                let feedback = `<strong>Incorrect.</strong> Here's the breakdown for <strong>${this.currentDrill.ip} /${this.currentDrill.cidr}</strong>:<br>`;
                feedback += `The correct Network ID was <strong>${this.currentDrill.correctNetworkId}</strong>.<br>`;
                feedback += `The correct Broadcast IP was <strong>${this.currentDrill.correctBroadcastIp}</strong>.<br><br>`;

                const mask = this.cidrToMask(this.currentDrill.cidr);
                const interestingOctetIndex = Math.floor((this.currentDrill.cidr - 1) / 8);
                const magicNumber = 256 - mask[interestingOctetIndex];

                feedback += `<strong>Step 1:</strong> The Magic Number for /${this.currentDrill.cidr} is <strong>${magicNumber}</strong> (since the mask octet is ${mask[interestingOctetIndex]}).<br>`;
                feedback += `<strong>Step 2:</strong> The Network ID is the block start. For the IP octet ${this.currentDrill.ip.split('.')[interestingOctetIndex]}, the block is <strong>${this.currentDrill.correctNetworkId}</strong>.<br>`;
                feedback += `<strong>Step 3:</strong> The Broadcast IP is the last address in that block, which is <strong>${this.currentDrill.correctBroadcastIp}</strong>.`;

                this.drillFeedbackEl.innerHTML = feedback;
            }
            this.drillFeedbackEl.style.display = 'block';
        }

        // CHAPTER 5: VLSM
        initChapter5() {
          // No interactive elements in this chapter
        }

        // CHAPTER 6: THE GAUNTLET (QUIZ)
        initChapter6() {
            this.quizDifficultyEl = document.getElementById('quizDifficulty');
            if(!this.quizDifficultyEl) return;
            this.quizScoreEl = document.getElementById('quizScore');
            this.quizQuestionEl = document.getElementById('quizQuestion');
            this.quizOptionsEl = document.getElementById('quizOptions');
            this.quizFeedbackEl = document.getElementById('quizFeedback');
            
            this.quizScore = 0;
            this.quizDifficultyEl.addEventListener('change', () => this.generateQuizQuestion());
            this.generateQuizQuestion();
        }
        
        generateQuizQuestion() {
            this.quizFeedbackEl.style.display = 'none';
            const level = parseInt(this.quizDifficultyEl.value);
            const ip = [10, Math.floor(Math.random()*256), Math.floor(Math.random()*256), Math.floor(Math.random()*254)+1].join('.');
            const cidr = Math.floor(Math.random() * (30-25+1)) + 25;
            
            this.currentQuiz = { ip, cidr };
            
            let question = {};
            
            switch(level) {
                case 1:
                    question.text = `What is the mask octet for <strong>/${cidr}</strong>?`;
                    question.correctAnswer = this.cidrToMask(cidr)[3];
                    break;
                case 2:
                    question.text = `Find the Network ID for <strong>${ip}/${cidr}</strong>.`;
                    question.correctAnswer = this.getNetworkID(this.ipToOctets(ip), cidr).join('.');
                    break;
                case 3: default:
                    const broadcast = this.getBroadcastAddress(this.getNetworkID(this.ipToOctets(ip), cidr), cidr);
                    question.text = `Find the Last Usable IP for <strong>${ip}/${cidr}</strong>.`;
                    question.correctAnswer = this.prevIp(broadcast).join('.');
                    break;
            }
            
            this.currentQuiz.correctAnswer = question.correctAnswer;

            let options = new Set([question.correctAnswer]);
            while(options.size < 4) {
                options.add(this.generateRandomAnswer(level));
            }
            
            this.quizQuestionEl.innerHTML = question.text;
            this.quizOptionsEl.innerHTML = '';
            [...options].sort(() => Math.random()-0.5).forEach(opt => {
                const btn = document.createElement('button');
                btn.className = 'option-btn';
                btn.textContent = opt;
                btn.addEventListener('click', () => this.checkQuizAnswer(opt));
                this.quizOptionsEl.appendChild(btn);
            });
        }
        
        generateRandomAnswer(level) {
            const randIp = [10, Math.floor(Math.random()*256), Math.floor(Math.random()*256), Math.floor(Math.random()*254)+1].join('.');
            const randCidr = Math.floor(Math.random() * (30-25+1)) + 25;
            
            switch(level) {
                case 1: return [128, 192, 224, 240, 248, 252][Math.floor(Math.random()*6)];
                case 2: return this.getNetworkID(this.ipToOctets(randIp), randCidr).join('.');
                case 3: default:
                    const randNet = this.getNetworkID(this.ipToOctets(randIp), randCidr);
                    return this.prevIp(this.getBroadcastAddress(randNet, randCidr)).join('.');
            }
        }
        
        checkQuizAnswer(selected) {
            if(selected === this.currentQuiz.correctAnswer) {
                this.quizScore++;
                this.quizFeedbackEl.style.display = 'block';
                this.quizFeedbackEl.style.background = 'rgba(0, 255, 136, 0.1)';
                this.quizFeedbackEl.style.borderColor = 'var(--net-color)';
                this.quizFeedbackEl.innerHTML = `<strong>Correct!</strong> Well done.`;
            } else {
                this.quizScore = 0;
                const mask = this.cidrToMask(this.currentQuiz.cidr);
                const magicNumber = 256 - mask[3];
                this.quizFeedbackEl.style.display = 'block';
                this.quizFeedbackEl.style.background = 'rgba(255, 71, 71, 0.1)';
                this.quizFeedbackEl.style.borderColor = 'var(--red-color)';
                this.quizFeedbackEl.innerHTML = `<strong>Incorrect.</strong> The correct answer was <strong>${this.currentQuiz.correctAnswer}</strong>. <br>Hint: The magic number for /${this.currentQuiz.cidr} is <strong>${magicNumber}</strong>.`;
            }
            this.quizScoreEl.textContent = `Score: ${this.quizScore}`;
            setTimeout(() => this.generateQuizQuestion(), 2500);
        }

        // CHAPTER 7: WILDCARD DRILL
        initChapter7() {
            this.wildcardQuizQuestionEl = document.getElementById('wildcardQuizQuestion');
            if (!this.wildcardQuizQuestionEl) return;
            this.wildcardQuizOptionsEl = document.getElementById('wildcardQuizOptions');
            this.wildcardQuizFeedbackEl = document.getElementById('wildcardQuizFeedback');
            this.generateWildcardQuizQuestion();
        }

        generateWildcardQuizQuestion() {
            this.wildcardQuizFeedbackEl.style.display = 'none';
            const cidr = Math.floor(Math.random() * (30 - 20 + 1)) + 20; // /20 to /30
            const correctAnswer = this.cidrToWildcard(cidr).join('.');

            this.currentWildcardQuiz = { cidr, correctAnswer };

            let options = new Set([correctAnswer]);
            while (options.size < 4) {
                const randomCidr = Math.floor(Math.random() * (30 - 20 + 1)) + 20;
                options.add(this.cidrToWildcard(randomCidr).join('.'));
            }

            this.wildcardQuizQuestionEl.innerHTML = `What is the <strong>wildcard mask</strong> for a /${cidr} subnet?`;
            this.wildcardQuizOptionsEl.innerHTML = '';
            [...options].sort(() => Math.random() - 0.5).forEach(opt => {
                const btn = document.createElement('button');
                btn.className = 'option-btn';
                btn.textContent = opt;
                btn.addEventListener('click', () => this.checkWildcardAnswer(opt));
                this.wildcardQuizOptionsEl.appendChild(btn);
            });
        }

        checkWildcardAnswer(selected) {
            if (selected === this.currentWildcardQuiz.correctAnswer) {
                this.wildcardQuizFeedbackEl.style.background = 'rgba(0, 255, 136, 0.1)';
                this.wildcardQuizFeedbackEl.style.borderColor = 'var(--net-color)';
                this.wildcardQuizFeedbackEl.innerHTML = `<strong>Correct!</strong> The wildcard for /${this.currentWildcardQuiz.cidr} is indeed ${this.currentWildcardQuiz.correctAnswer}.`;
            } else {
                this.wildcardQuizFeedbackEl.style.background = 'rgba(255, 71, 71, 0.1)';
                this.wildcardQuizFeedbackEl.style.borderColor = 'var(--red-color)';
                this.wildcardQuizFeedbackEl.innerHTML = `<strong>Incorrect.</strong> The correct answer was <strong>${this.currentWildcardQuiz.correctAnswer}</strong>. Remember, wildcard = 255.255.255.255 - subnet mask.`;
            }
            this.wildcardQuizFeedbackEl.style.display = 'block';
            setTimeout(() => this.generateWildcardQuizQuestion(), 3000);
        }

        // CHAPTER 8: REVERSE CIDR CHALLENGE
        initChapter8() {
            this.reverseCidrQuizQuestionEl = document.getElementById('reverseCidrQuizQuestion');
            if (!this.reverseCidrQuizQuestionEl) return;
            this.reverseCidrQuizOptionsEl = document.getElementById('reverseCidrQuizOptions');
            this.reverseCidrQuizFeedbackEl = document.getElementById('reverseCidrQuizFeedback');
            this.generateReverseCidrQuizQuestion();
        }

        generateReverseCidrQuizQuestion() {
            this.reverseCidrQuizFeedbackEl.style.display = 'none';
            const cidr = Math.floor(Math.random() * (29 - 23 + 1)) + 23; // /23 to /29
            const networkIpBase = [192, 168, Math.floor(Math.random()*50), 0];
            
            const networkID = this.getNetworkID(networkIpBase, cidr);
            const broadcast = this.getBroadcastAddress(networkID, cidr);
            const correctAnswer = `/${cidr}`;

            this.currentReverseCidrQuiz = { correctAnswer };

            let options = new Set([correctAnswer]);
            while (options.size < 4) {
                 const randomCidr = Math.floor(Math.random() * (29 - 23 + 1)) + 23;
                 options.add(`/${randomCidr}`);
            }
            
            this.reverseCidrQuizQuestionEl.innerHTML = `Network ID: <strong>${networkID.join('.')}</strong> <br> Broadcast: <strong>${broadcast.join('.')}</strong> <br> What is the CIDR notation?`;
            this.reverseCidrQuizOptionsEl.innerHTML = '';
            [...options].sort(() => Math.random() - 0.5).forEach(opt => {
                const btn = document.createElement('button');
                btn.className = 'option-btn';
                btn.textContent = opt;
                btn.addEventListener('click', () => this.checkReverseCidrAnswer(opt));
                this.reverseCidrQuizOptionsEl.appendChild(btn);
            });
        }

        checkReverseCidrAnswer(selected) {
             if (selected === this.currentReverseCidrQuiz.correctAnswer) {
                this.reverseCidrQuizFeedbackEl.style.background = 'rgba(0, 255, 136, 0.1)';
                this.reverseCidrQuizFeedbackEl.style.borderColor = 'var(--net-color)';
                this.reverseCidrQuizFeedbackEl.innerHTML = `<strong>Correct!</strong> You reverse-engineered the CIDR perfectly.`;
            } else {
                this.reverseCidrQuizFeedbackEl.style.background = 'rgba(255, 71, 71, 0.1)';
                this.reverseCidrQuizFeedbackEl.style.borderColor = 'var(--red-color)';
                this.reverseCidrQuizFeedbackEl.innerHTML = `<strong>Not quite.</strong> The correct CIDR was <strong>${this.currentReverseCidrQuiz.correctAnswer}</strong>. Hint: Count the total IPs in the range to find the host bits.`;
            }
            this.reverseCidrQuizFeedbackEl.style.display = 'block';
            setTimeout(() => this.generateReverseCidrQuizQuestion(), 3000);
        }
        
        // CHAPTER 9: AI MENTOR
        initChapter9() {
            this.aiChatWindow = document.getElementById('aiChatWindow');
            if(!this.aiChatWindow) return;
            this.aiChatInput = document.getElementById('aiChatInput');
            
            this.aiChatInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    this.handleUserMessage();
                }
            });
            this.addChatMessage("Hello, Recruit. I am the Cyber Mentor AI. Ask me about subnetting concepts, or tell me to 'create a quiz'.", "ai");
        }
        
        handleUserMessage() {
            const userInput = this.aiChatInput.value.trim();
            if (!userInput) return;
            
            this.addChatMessage(userInput, "user");
            this.aiChatInput.value = '';
            
            setTimeout(() => {
                const aiResponse = this.getAIResponse(userInput);
                this.addChatMessage(aiResponse, "ai");
            }, 800);
        }
        
        addChatMessage(text, author) {
            const messageDiv = document.createElement('div');
            messageDiv.className = `chat-message ${author}`;
            messageDiv.innerHTML = `<div class="author">${author === 'ai' ? 'AI Mentor' : 'You'}</div><div class="text">${text}</div>`;
            this.aiChatWindow.appendChild(messageDiv);
            this.aiChatWindow.scrollTop = this.aiChatWindow.scrollHeight;
        }

        getAIResponse(input) {
            const text = input.toLowerCase();
            const quizKeywords = ["create quiz", "new question", "quiz me", "quiz"];

            if (text.includes("what are you") || text.includes("who are you")) {
                return "I am the AI Cyber Mentor for this training module. My purpose is to help you master subnetting by providing definitions and generating practice questions.";
            }
            if (text.includes("start") || text.includes("begin") || text.includes("basics")) {
                const chapter1 = document.getElementById('chapter-1');
                if (chapter1) {
                    chapter1.open = true;
                    chapter1.scrollIntoView({ behavior: 'smooth' });
                }
                return "Of course. The best place to start is <strong>Chapter 1: The Fundamentals</strong>. It explains what an IP address is and how binary numbers work. I've opened it for you.";
            }
            if (text.includes("calculate") || text.includes("how to") || text.includes("steps")) {
                return "The fastest way to calculate a subnet is using the <strong>Magic Number method</strong>: <br>1. Find the 'interesting' mask octet (the one that isn't 255). <br>2. Calculate the Magic Number: <code>256 - [mask octet]</code>. This is your block size. <br>3. Find the network block your IP fits into by finding the multiple of the Magic Number that is less than or equal to your IP's octet. <br>For a detailed, animated example, see <strong>Chapter 4: The Ultimate Calculator</strong>.";
            }
            if (text.includes("cidr")) {
                return "<strong>CIDR (Classless Inter-Domain Routing)</strong> is the modern way to define the size of a network. The number (e.g., /24) represents how many bits of the IP address are for the <strong style='color: var(--net-color)'>network portion</strong>. A higher number means more network bits and fewer host bits.";
            }
            if (quizKeywords.some(kw => text.includes(kw))) {
                const chapter6 = document.getElementById('chapter-6');
                if (chapter6) {
                    chapter6.open = true;
                    chapter6.scrollIntoView({ behavior: 'smooth' });
                }
                this.generateQuizQuestion();
                return "Understood. I have generated a new question for you in <strong>Chapter 6: The Gauntlet</strong>.";
            }
            if (text.includes("network id")) {
                return "The <strong>Network ID</strong> is the very first address in a subnet. It represents the entire network and cannot be assigned to a single device.";
            }
            if (text.includes("broadcast")) {
                return "The <strong>Broadcast Address</strong> is the very last address in a subnet. Sending data to this address sends it to every device on that specific subnet.";
            }
            if (text.includes("magic number")) {
                return "The <strong>Magic Number</strong> (or Block Size) is the key to fast subnetting. You calculate it with <code>256 - [the interesting mask octet]</code>. It tells you the total number of IPs in the subnet and where each new subnet begins (e.g., 0, 32, 64...).";
            }
            if (text.includes("vlsm")) {
                return "<strong>VLSM</strong> stands for Variable Length Subnet Masking. It's a technique to create subnets of different sizes from a larger address block. This is very efficient because you can create a small subnet for a link that only needs 2 IPs, and a larger subnet for a department that needs 50 IPs, all from the same main block.";
            }
            if (text.includes("hint") || text.includes("help")) {
                if (this.currentQuiz) {
                    const mask = this.cidrToMask(this.currentQuiz.cidr);
                    const magicNumber = 256 - mask[3];
                    return `Here's a hint for the current quiz question: The CIDR is /${this.currentQuiz.cidr}. The magic number is <strong>${magicNumber}</strong>. Use that to calculate the answer.`;
                }
                return "I can only provide hints for an active quiz. A new quiz has been generated for you in Chapter 6.";
            }
            if (text.includes("hello") || text.includes("hi")) {
                return "Hello. How can I assist you with your subnetting training?";
            }
            
            return "I am a specialized AI. My knowledge is focused on subnetting. Try asking me 'what is a network id?', 'explain vlsm', 'how do I calculate subnet?', or tell me to 'create a quiz'.";
        }


        // UTILITY METHODS
        sleep(ms) { return new Promise(resolve => setTimeout(resolve, ms)); }
        ipToOctets(ip) {
            const parts = ip.trim().split('.');
            if (parts.length !== 4) return null;
            const octets = parts.map(p => parseInt(p, 10));
            return octets.some(o => isNaN(o) || o < 0 || o > 255) ? null : octets;
        }
        cidrToMask(cidr) {
            const mask = [0, 0, 0, 0];
            for (let i = 0; i < cidr; i++) mask[Math.floor(i / 8)] |= 1 << (7 - (i % 8));
            return mask;
        }
        cidrToWildcard(cidr) {
            const mask = this.cidrToMask(cidr);
            return mask.map(octet => 255 - octet);
        }
        getNetworkID(octets, cidr) {
            const mask = this.cidrToMask(cidr);
            return octets.map((octet, i) => octet & mask[i]);
        }
        getBroadcastAddress(networkID, cidr) {
            const broadcast = [...networkID];
            for (let i = 31; i >= cidr; i--) {
                broadcast[Math.floor(i / 8)] |= 1 << (7 - (i % 8));
            }
            return broadcast;
        }
        nextIp(octets) {
            const newOctets = [...octets];
            for (let i = 3; i >= 0; i--) {
                if (newOctets[i] < 255) { newOctets[i]++; break; }
                newOctets[i] = 0;
            }
            return newOctets;
        }
        prevIp(octets) {
            const newOctets = [...octets];
            for (let i = 3; i >= 0; i--) {
                if (newOctets[i] > 0) { newOctets[i]--; break; }
                newOctets[i] = 255;
            }
            return newOctets;
        }
    }

    new MasterclassApp();
});
</script>
</body>
</html>

</body>
</html>
